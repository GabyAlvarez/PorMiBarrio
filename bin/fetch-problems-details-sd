#!/usr/bin/env perl

use strict;
use warnings;
use DateTime;
use DateTime::Format::W3CDTF;
use ServiceDesk::GetServiceRequestUpdates;
use Memcached;
use Data::Dumper;
require 5.8.0;

use FixMyStreet::App;
use CronFns;
my ($verbose, $nomail) = CronFns::options();

use Open311;
#TODO: integrate with fetch for all
my $bodies = FixMyStreet::App->model('DB::Body')->search(
  {
      send_method     => 'ServiceDesk',
      comment_user_id => { '!=', undef },
      endpoint        => { '!=', '' },
  }
);
while ( my $body = $bodies->next ) {
  my %where;
  #Memcached::set_namespace( FixMyStreet->config('FMS_DB_NAME') . ":" );
  #Get external_ids for looping
  my @report_list;
  #my $mem_current_list = Memcached::get('sd_update_details_current_'.$body->id);
  #my $mem_update_list = Memcached::get('sd_update_details_tail_'.$body->id);
  #if ( !@{$mem_update_list} || !@{$mem_current_list} ){
    $where{external_id} = \'is not null';
    $where{bodies_str} = { '=', $body->id };
    $where{state} = { -in => [ FixMyStreet::DB::Result::Problem->open_states() ] };
    @report_list = map { $_->id } FixMyStreet::App->model('DB::Problem')->search( \%where, {
      order_by => { -asc => 'lastcheck' },
      columns => [ 'id' ],
      limit => 20
    } );
    #Memcached::set('sd_update_details_tail_'.$body->id, \@report_list);
    #Every 2 days list is refreshed
    #Memcached::set('sd_update_details_current_'.$body->id, 1, 7200);
 # }
 # else {
 #   print 'VA POR LIST MEM';
 #   print Dumper($mem_update_list);
 #   @report_list = @{$mem_update_list};
 # }
  #my @actual_list = splice @report_list, 0, 20;
  #print Dumper(@actual_list);
  #Memcached::set('sd_update_details_tail_'.$body->id, \@report_list);
  my $service = ServiceDesk::GetServiceRequestUpdates->new( verbose => 1 );
  #@report_list = (3349);
  $service->fetch_details(\@report_list);
}
